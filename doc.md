# 设计文档

> Keep it simple and stupid.

本次大作业力求采用最简的实现完成全部功能，**主体框架为一个`QMainWindow`嵌套一个作为`centralWidget`的`QWidget`**。外层的`QMainWindow`负责维护菜单栏、工具栏和状态栏，内层的`QWidget`负责处理游戏逻辑。

受个人较为熟悉的`React`框架的影响，在游戏逻辑处理的部分，**我将游戏过程中的所有变量统一整合为一个大状态`GameState`，并在其发生改变时发起页面重绘**：

```C++
struct GameState {
    Status status;               // 游戏状态（指未开始、开始、暂停、结束）
    std::list<Point> snake;      // 蛇的位置
    Direction direction;         // 蛇的运动方向
    Direction nextDirection;     // 用于暂存键盘按键
    Point food;                  // 食物的位置
    std::set<Point> barriers;    // 障碍物的位置
    int growth;                  // 蛇还需要增长的单位数
    int speed;                   // 速度，在本次大作业中其实没有变化
    int ticks;                   // 蛇移动的路程
};
```

由于`GameState`包含了游戏中所有可能的变量，仅根据`GameState`就完全可以满足页面重绘的需求。同理，**持久化的过程也能够仅根据`GameState`完成**。

我使用计时器`QTimer`实现贪吃蛇的定时移动，将计时器与蛇的移动逻辑绑定起来，并在游戏状态切换时恰当地启动或暂停计时器。

键盘和鼠标事件分别通过重写`QWidget`的`keyPressEvent`和`mousePressEvent`方法实现。在处理键盘事件方面，**我用`GameState`的`nextDirection`成员暂存用户的按键，而不是直接唤起蛇的移动**，以实现较为理想的转向效果。在处理鼠标事件方面，我对用户鼠标点击的位置进行简单计算后，确定需要设置或移除障碍的坐标。

此外，我用`GameState`的`growth`成员维护贪吃蛇的增长情况。具体而言，当蛇吃到食物时，我将`growth`设置为3；此后，蛇每移动一步，`growth`的值就减小`1`，直到减小至`0`为止。

## 细节处理

### 窗口大小动态适配

为保证游戏棋盘始终位于窗口中央，且占据尽可能大的空间，需对`resizeEvent`方法进行重写。此外，我还为游戏逻辑添加了类型为`BoardOccupation`的成员变量`boardOccupation`，用于记录游戏棋盘的实时位置和尺寸：

```C++
struct BoardOccupation {
    int x, y, boardSize, gridSize;
};
```

`boardOccupation`的数值在重写的`resizeEvent`方法中进行计算，并为`paintEvent`和`mousePressEvent`方法所使用。

### 文件读写

使用`JSON`格式存储游戏数据，以增加存档文件的可读性。这一点可以借助`Qt`提供的封装好的`JSON`库方便地实现。此外，对读入的文件进行了简单的检查，如当蛇的`X`坐标与`Y`坐标列表长度不一致时，提示读取失败。

## 心得体会

我对`Qt`框架的预编译过程感触颇深。在完成本次大作业的过程中，我多次对其预编译生成的文件进行了一定的探索。`Qt`的预编译器能将简单的`.xml`格式的文件转化为详细的`C++`中间代码，**这事实上大大减少了项目本身的代码量**，减轻了程序员的工作。此外，**利用好这一预编译过程可以在一定程度上减少冗余代码，这对于提升项目的可维护性也是大有裨益的**。

我热衷于保持代码的简明和可维护性，在最后一次重构中，我对`.ui`文件进行了一定的手动调整，更好地利用了自定义组件以及信号槽机制，从而降低了窗口页面和游戏逻辑之间的耦合度，并进一步将一些冗余代码交由预编译环节完成。经历这一次重构之后，我再一次感受到了`Qt`预编译环节的强大。